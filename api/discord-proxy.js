const Formidable = require('formidable');
const fetch = require('node-fetch');
const FormData = require('form-data');
const fs = require('fs');

// Vercel/Netlify configuration to disable default body parsing, allowing Formidable to work.
// This is critical for handling file uploads (multipart/form-data).
export const config = {
  api: {
    bodyParser: false, 
  },
};

export default async (req, res) => {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).send('Method Not Allowed');
  }

  // ðŸš¨ SECURITY FIX: Get the Webhook URL from the secure Vercel/Netlify Environment Variables
  const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;

  if (!DISCORD_WEBHOOK_URL) {
    // This is the source of a 500 error if the variable is missing
    console.error('Environment Variable DISCORD_WEBHOOK_URL is not set.');
    return res.status(500).json({ success: false, message: 'Server Error: Webhook URL is missing from environment variables.' });
  }

  // Initialize Formidable (Fixes "formidable is not a function" error)
  const form = new Formidable.IncomingForm();

  // Parse the incoming request (which contains text fields and files)
  form.parse(req, async (err, fields, files) => {
    if (err) {
      console.error('Formidable Parsing Error:', err);
      return res.status(500).json({ success: false, message: 'Failed to parse form data.' });
    }

    // Re-package the incoming request into a new FormData for Discord
    const formDataToDiscord = new FormData();

    // 1. Append Text Fields (payload_json)
    // Formidable v3 returns fields as an object of arrays, so we extract the first element
    for (const key in fields) {
        formDataToDiscord.append(key, fields[key][0]);
    }

    // 2. Append File Data (Handles the uploaded file)
    // Files are stored in the 'files' object by their input name (e.g., file0, file1, etc.)
    const fileKeys = Object.keys(files); 
    if (fileKeys.length > 0) {
        fileKeys.forEach((key, index) => {
             const file = files[key][0]; // Extract the file object
             // Append file using a read stream for better memory efficiency
             formDataToDiscord.append(`file${index}`, fs.createReadStream(file.filepath), {
                filename: file.originalFilename || `uploaded_file_${index}`,
                contentType: file.mimetype || 'application/octet-stream',
             });
        });
    }

    // 3. Proxy the Request to Discord
    try {
      const discordResponse = await fetch(DISCORD_WEBHOOK_URL, {
        method: 'POST',
        // Pass the re-created form data to the Discord URL
        body: formDataToDiscord,
        // MUST include headers generated by form-data
        headers: formDataToDiscord.getHeaders(), 
      });

      if (discordResponse.ok) {
        return res.status(200).json({ success: true, message: 'Report sent successfully.' });
      } else {
        const errorDetails = await discordResponse.text();
        console.error('Discord Proxy Error:', discordResponse.status, errorDetails);
        return res.status(discordResponse.status).json({ success: false, message: 'Failed to proxy request to Discord.', details: errorDetails });
      }
    } catch (fetchError) {
      console.error('Fetch Error:', fetchError);
      return res.status(500).json({ success: false, message: 'Network error during proxy attempt.' });
    }
  });
};
